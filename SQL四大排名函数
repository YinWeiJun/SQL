参考： https://www.cnblogs.com/52XF/p/4209211.html

一、ROW_NUMBER

    row_number的用途的非常广泛，排序最好用他，一般可以用来实现web程序的分页，他会为查询出来的每一行记录生成一个序号，
                                                                                      ---------------------
依次排序且不会重复，注意使用row_number函数时必须要用over子句选择对某一列进行排序才能生成序号。row_number用法实例:
-----------------
    select ROW_NUMBER() OVER(order by [SubTime] desc) as row_num,* from [Order]
    
二、RANK

　　rank函数用于返回结果集的分区内每行的排名， 行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进
                               ------------------------------------------
行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句

中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解
  ---------------------------------------------------------------------------------------------------
为根据当前的记录数生成序号，后面的记录依此类推。可能我描述的比较苍白，理解起来也比较吃力，我们直接上代码，rank函数的使用

方法与row_number函数完全相同。

    select RANK() OVER(order by [UserId]) as rank,* from [Order] 
    
三、DENSE_RANK

　　dense_rank函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。dense_rank
                                                     -------------------------------------------------
函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是
   --------------------------------
第四名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。将上面的Sql语句改由dense_rank函数来实现。

    select DENSE_RANK() OVER(order by [UserId]) as den_rank,* from [Order]
    
四、NTILE

　　ntile函数可以对序号进行分组处理，将有序分区中的行分发到指定数目的组中。 各个组有编号，编号从一开始。 对于每一个行，ntile
                         --------
将返回此行所属的组的编号。这就相当于将查询出来的记录集放到指定长度的数组中，每一个数组元素存放一定数量的记录。ntile函数为每条
                                 -------------------------------------------------------------------
记录生成的序号就是这条记录所有的数组元素的索引（从1开始）。也可以将每一个分配记录的数组元素称为“桶”。ntile函数有一个参数，用

来指定桶数。下面的SQL语句使用ntile函数对Order表进行了装桶处理：

    select NTILE(4) OVER(order by [SubTime] desc) as ntile,* from [Order]
    
    
    
    
    
    
    
    
    
    
